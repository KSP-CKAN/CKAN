#!/usr/bin/perl

# This chunk of stuff was generated by App::FatPacker. To find the original
# file's code, look for the end of this BEGIN block or the string 'FATPACK'
BEGIN {
my %fatpacked;

$fatpacked{"File/Copy/Recursive.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'FILE_COPY_RECURSIVE';
  package File::Copy::Recursive;
  
  use strict;
  BEGIN {
      # Keep older versions of Perl from trying to use lexical warnings
      $INC{'warnings.pm'} = "fake warnings entry for < 5.6 perl ($])" if $] < 5.006;
  }
  use warnings;
  
  use Carp;
  use File::Copy; 
  use File::Spec; #not really needed because File::Copy already gets it, but for good measure :)
  
  use vars qw( 
      @ISA      @EXPORT_OK $VERSION  $MaxDepth $KeepMode $CPRFComp $CopyLink 
      $PFSCheck $RemvBase $NoFtlPth  $ForcePth $CopyLoop $RMTrgFil $RMTrgDir 
      $CondCopy $BdTrgWrn $SkipFlop  $DirPerms
  );
  
  require Exporter;
  @ISA = qw(Exporter);
  @EXPORT_OK = qw(fcopy rcopy dircopy fmove rmove dirmove pathmk pathrm pathempty pathrmdir);
  $VERSION = '0.38';
  
  $MaxDepth = 0;
  $KeepMode = 1;
  $CPRFComp = 0; 
  $CopyLink = eval { local $SIG{'__DIE__'};symlink '',''; 1 } || 0;
  $PFSCheck = 1;
  $RemvBase = 0;
  $NoFtlPth = 0;
  $ForcePth = 0;
  $CopyLoop = 0;
  $RMTrgFil = 0;
  $RMTrgDir = 0;
  $CondCopy = {};
  $BdTrgWrn = 0;
  $SkipFlop = 0;
  $DirPerms = 0777; 
  
  my $samecheck = sub {
     return 1 if $^O eq 'MSWin32'; # need better way to check for this on winders...
     return if @_ != 2 || !defined $_[0] || !defined $_[1];
     return if $_[0] eq $_[1];
  
     my $one = '';
     if($PFSCheck) {
        $one    = join( '-', ( stat $_[0] )[0,1] ) || '';
        my $two = join( '-', ( stat $_[1] )[0,1] ) || '';
        if ( $one eq $two && $one ) {
            carp "$_[0] and $_[1] are identical";
            return;
        }
     }
  
     if(-d $_[0] && !$CopyLoop) {
        $one    = join( '-', ( stat $_[0] )[0,1] ) if !$one;
        my $abs = File::Spec->rel2abs($_[1]);
        my @pth = File::Spec->splitdir( $abs );
        while(@pth) {
           my $cur = File::Spec->catdir(@pth);
           last if !$cur; # probably not necessary, but nice to have just in case :)
           my $two = join( '-', ( stat $cur )[0,1] ) || '';
           if ( $one eq $two && $one ) {
               # $! = 62; # Too many levels of symbolic links
               carp "Caught Deep Recursion Condition: $_[0] contains $_[1]";
               return;
           }
        
           pop @pth;
        }
     }
  
     return 1;
  };
  
  my $glob = sub {
      my ($do, $src_glob, @args) = @_;
      
      local $CPRFComp = 1;
      
      my @rt;
      for my $path ( glob($src_glob) ) {
          my @call = [$do->($path, @args)] or return;
          push @rt, \@call;
      }
      
      return @rt;
  };
  
  my $move = sub {
     my $fl = shift;
     my @x;
     if($fl) {
        @x = fcopy(@_) or return;
     } else {
        @x = dircopy(@_) or return;
     }
     if(@x) {
        if($fl) {
           unlink $_[0] or return;
        } else {
           pathrmdir($_[0]) or return;
        }
        if($RemvBase) {
           my ($volm, $path) = File::Spec->splitpath($_[0]);
           pathrm(File::Spec->catpath($volm,$path,''), $ForcePth, $NoFtlPth) or return;
        }
     }
    return wantarray ? @x : $x[0];
  };
  
  my $ok_todo_asper_condcopy = sub {
      my $org = shift;
      my $copy = 1;
      if(exists $CondCopy->{$org}) {
          if($CondCopy->{$org}{'md5'}) {
  
          }
          if($copy) {
  
          }
      }
      return $copy;
  };
  
  sub fcopy { 
     $samecheck->(@_) or return;
     if($RMTrgFil && (-d $_[1] || -e $_[1]) ) {
        my $trg = $_[1];
        if( -d $trg ) {
          my @trgx = File::Spec->splitpath( $_[0] );
          $trg = File::Spec->catfile( $_[1], $trgx[ $#trgx ] );
        }
        $samecheck->($_[0], $trg) or return;
        if(-e $trg) {
           if($RMTrgFil == 1) {
              unlink $trg or carp "\$RMTrgFil failed: $!";
           } else {
              unlink $trg or return;
           }
        }
     }
     my ($volm, $path) = File::Spec->splitpath($_[1]);
     if($path && !-d $path) {
        pathmk(File::Spec->catpath($volm,$path,''), $NoFtlPth);
     }
     if( -l $_[0] && $CopyLink ) {
        carp "Copying a symlink ($_[0]) whose target does not exist" 
            if !-e readlink($_[0]) && $BdTrgWrn;
        symlink readlink(shift()), shift() or return;
     } else {  
        copy(@_) or return;
  
        my @base_file = File::Spec->splitpath($_[0]);
        my $mode_trg = -d $_[1] ? File::Spec->catfile($_[1], $base_file[ $#base_file ]) : $_[1];
  
        chmod scalar((stat($_[0]))[2]), $mode_trg if $KeepMode;
     }
     return wantarray ? (1,0,0) : 1; # use 0's incase they do math on them and in case rcopy() is called in list context = no uninit val warnings
  }
  
  sub rcopy { 
      if (-l $_[0] && $CopyLink) {
          goto &fcopy;    
      }
      
      goto &dircopy if -d $_[0] || substr( $_[0], ( 1 * -1), 1) eq '*';
      goto &fcopy;
  }
  
  sub rcopy_glob {
      $glob->(\&rcopy, @_);
  }
  
  sub dircopy {
     if($RMTrgDir && -d $_[1]) {
        if($RMTrgDir == 1) {
           pathrmdir($_[1]) or carp "\$RMTrgDir failed: $!";
        } else {
           pathrmdir($_[1]) or return;
        }
     }
     my $globstar = 0;
     my $_zero = $_[0];
     my $_one = $_[1];
     if ( substr( $_zero, ( 1 * -1 ), 1 ) eq '*') {
         $globstar = 1;
         $_zero = substr( $_zero, 0, ( length( $_zero ) - 1 ) );
     }
  
     $samecheck->(  $_zero, $_[1] ) or return;
     if ( !-d $_zero || ( -e $_[1] && !-d $_[1] ) ) {
         $! = 20; 
         return;
     } 
  
     if(!-d $_[1]) {
        pathmk($_[1], $NoFtlPth) or return;
     } else {
        if($CPRFComp && !$globstar) {
           my @parts = File::Spec->splitdir($_zero);
           while($parts[ $#parts ] eq '') { pop @parts; }
           $_one = File::Spec->catdir($_[1], $parts[$#parts]);
        }
     }
     my $baseend = $_one;
     my $level   = 0;
     my $filen   = 0;
     my $dirn    = 0;
  
     my $recurs; #must be my()ed before sub {} since it calls itself
     $recurs =  sub {
        my ($str,$end,$buf) = @_;
        $filen++ if $end eq $baseend; 
        $dirn++ if $end eq $baseend;
        
        $DirPerms = oct($DirPerms) if substr($DirPerms,0,1) eq '0';
        mkdir($end,$DirPerms) or return if !-d $end;
        chmod scalar((stat($str))[2]), $end if $KeepMode;
        if($MaxDepth && $MaxDepth =~ m/^\d+$/ && $level >= $MaxDepth) {
           return ($filen,$dirn,$level) if wantarray;
           return $filen;
        }
        $level++;
  
        
        my @files;
        if ( $] < 5.006 ) {
            opendir(STR_DH, $str) or return;
            @files = grep( $_ ne '.' && $_ ne '..', readdir(STR_DH));
            closedir STR_DH;
        }
        else {
            opendir(my $str_dh, $str) or return;
            @files = grep( $_ ne '.' && $_ ne '..', readdir($str_dh));
            closedir $str_dh;
        }
  
        for my $file (@files) {
            my ($file_ut) = $file =~ m{ (.*) }xms;
            my $org = File::Spec->catfile($str, $file_ut);
            my $new = File::Spec->catfile($end, $file_ut);
            if( -l $org && $CopyLink ) {
                carp "Copying a symlink ($org) whose target does not exist" 
                    if !-e readlink($org) && $BdTrgWrn;
                symlink readlink($org), $new or return;
            } 
            elsif(-d $org) {
                $recurs->($org,$new,$buf) if defined $buf;
                $recurs->($org,$new) if !defined $buf;
                $filen++;
                $dirn++;
            } 
            else {
                if($ok_todo_asper_condcopy->($org)) {
                    if($SkipFlop) {
                        fcopy($org,$new,$buf) or next if defined $buf;
                        fcopy($org,$new) or next if !defined $buf;                      
                    }
                    else {
                        fcopy($org,$new,$buf) or return if defined $buf;
                        fcopy($org,$new) or return if !defined $buf;
                    }
                    chmod scalar((stat($org))[2]), $new if $KeepMode;
                    $filen++;
                }
            }
        }
        1;
     };
  
     $recurs->($_zero, $_one, $_[2]) or return;
     return wantarray ? ($filen,$dirn,$level) : $filen;
  }
  
  sub fmove { $move->(1, @_) } 
  
  sub rmove { 
      if (-l $_[0] && $CopyLink) {
          goto &fmove;    
      }
      
      goto &dirmove if -d $_[0] || substr( $_[0], ( 1 * -1), 1) eq '*';
      goto &fmove;
  }
  
  sub rmove_glob {
      $glob->(\&rmove, @_);
  }
  
  sub dirmove { $move->(0, @_) }
  
  sub pathmk {
     my @parts = File::Spec->splitdir( shift() );
     my $nofatal = shift;
     my $pth = $parts[0];
     my $zer = 0;
     if(!$pth) {
        $pth = File::Spec->catdir($parts[0],$parts[1]);
        $zer = 1;
     }
     for($zer..$#parts) {
        $DirPerms = oct($DirPerms) if substr($DirPerms,0,1) eq '0';
        mkdir($pth,$DirPerms) or return if !-d $pth && !$nofatal;
        mkdir($pth,$DirPerms) if !-d $pth && $nofatal;
        $pth = File::Spec->catdir($pth, $parts[$_ + 1]) unless $_ == $#parts;
     }
     1;
  } 
  
  sub pathempty {
     my $pth = shift; 
  
     return 2 if !-d $pth;
  
     my @names;
     my $pth_dh;
     if ( $] < 5.006 ) {
         opendir(PTH_DH, $pth) or return;
         @names = grep !/^\.+$/, readdir(PTH_DH);
     }
     else {
         opendir($pth_dh, $pth) or return;
         @names = grep !/^\.+$/, readdir($pth_dh);       
     }
     
     for my $name (@names) {
        my ($name_ut) = $name =~ m{ (.*) }xms;
        my $flpth     = File::Spec->catdir($pth, $name_ut);
  
        if( -l $flpth ) {
  	      unlink $flpth or return; 
        }
        elsif(-d $flpth) {
            pathrmdir($flpth) or return;
        } 
        else {
            unlink $flpth or return;
        }
     }
  
     if ( $] < 5.006 ) {
         closedir PTH_DH;
     }
     else {
         closedir $pth_dh;
     }
     
     1;
  }
  
  sub pathrm {
     my $path = shift;
     return 2 if !-d $path;
     my @pth = File::Spec->splitdir( $path );
     my $force = shift;
  
     while(@pth) { 
        my $cur = File::Spec->catdir(@pth);
        last if !$cur; # necessary ??? 
        if(!shift()) {
           pathempty($cur) or return if $force;
           rmdir $cur or return;
        } 
        else {
           pathempty($cur) if $force;
           rmdir $cur;
        }
        pop @pth;
     }
     1;
  }
  
  sub pathrmdir {
      my $dir = shift;
      if( -e $dir ) {
          return if !-d $dir;
      }
      else {
          return 2;
      }
  
      pathempty($dir) or return;
      
      rmdir $dir or return;
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  File::Copy::Recursive - Perl extension for recursively copying files and directories
  
  =head1 SYNOPSIS
  
    use File::Copy::Recursive qw(fcopy rcopy dircopy fmove rmove dirmove);
  
    fcopy($orig,$new[,$buf]) or die $!;
    rcopy($orig,$new[,$buf]) or die $!;
    dircopy($orig,$new[,$buf]) or die $!;
  
    fmove($orig,$new[,$buf]) or die $!;
    rmove($orig,$new[,$buf]) or die $!;
    dirmove($orig,$new[,$buf]) or die $!;
    
    rcopy_glob("orig/stuff-*", $trg [, $buf]) or die $!;
    rmove_glob("orig/stuff-*", $trg [,$buf]) or die $!;
  
  =head1 DESCRIPTION
  
  This module copies and moves directories recursively (or single files, well... singley) to an optional depth and attempts to preserve each file or directory's mode.
  
  =head1 EXPORT
  
  None by default. But you can export all the functions as in the example above and the path* functions if you wish.
  
  =head2 fcopy()
  
  This function uses File::Copy's copy() function to copy a file but not a directory. Any directories are recursively created if need be.
  One difference to File::Copy::copy() is that fcopy attempts to preserve the mode (see Preserving Mode below)
  The optional $buf in the synopsis if the same as File::Copy::copy()'s 3rd argument
  returns the same as File::Copy::copy() in scalar context and 1,0,0 in list context to accomidate rcopy()'s list context on regular files. (See below for more info)
  
  =head2 dircopy()
  
  This function recursively traverses the $orig directory's structure and recursively copies it to the $new directory.
  $new is created if necessary (multiple non existant directories is ok (IE foo/bar/baz). The script logically and portably creates all of them if necessary).
  It attempts to preserve the mode (see Preserving Mode below) and 
  by default it copies all the way down into the directory, (see Managing Depth) below.
  If a directory is not specified it croaks just like fcopy croaks if its not a file that is specified.
  
  returns true or false, for true in scalar context it returns the number of files and directories copied,
  In list context it returns the number of files and directories, number of directories only, depth level traversed.
  
    my $num_of_files_and_dirs = dircopy($orig,$new);
    my($num_of_files_and_dirs,$num_of_dirs,$depth_traversed) = dircopy($orig,$new);
    
  Normally it stops and return's if a copy fails, to continue on regardless set $File::Copy::Recursive::SkipFlop to true.
  
      local $File::Copy::Recursive::SkipFlop = 1;
  
  That way it will copy everythgingit can ina directory and won't stop because of permissions, etc...
  
  =head2 rcopy()
  
  This function will allow you to specify a file *or* directory. It calls fcopy() if its a file and dircopy() if its a directory.
  If you call rcopy() (or fcopy() for that matter) on a file in list context, the values will be 1,0,0 since no directories and no depth are used. 
  This is important becasue if its a directory in list context and there is only the initial directory the return value is 1,1,1.
  
  =head2 rcopy_glob()
  
  This function lets you specify a pattern suitable for perl's glob() as the first argument. Subsequently each path returned by perl's glob() gets rcopy()ied.
  
  It returns and array whose items are array refs that contain the return value of each rcopy() call.
  
  It forces behavior as if $File::Copy::Recursive::CPRFComp is true.
  
  =head2 fmove()
  
  Copies the file then removes the original. You can manage the path the original file is in according to $RemvBase.
  
  =head2 dirmove()
  
  Uses dircopy() to copy the directory then removes the original. You can manage the path the original directory is in according to $RemvBase.
  
  =head2 rmove()
  
  Like rcopy() but calls fmove() or dirmove() instead.
  
  =head2 rmove_glob()
  
  Like rcopy_glob() but calls rmove() instead of rcopy()
  
  =head3 $RemvBase
  
  Default is false. When set to true the *move() functions will not only attempt to remove the original file or directory but will remove the given path it is in.
  
  So if you:
  
     rmove('foo/bar/baz', '/etc/');
     # "baz" is removed from foo/bar after it is successfully copied to /etc/
     
     local $File::Copy::Recursive::Remvbase = 1;
     rmove('foo/bar/baz','/etc/');
     # if baz is successfully copied to /etc/ :
     # first "baz" is removed from foo/bar
     # then "foo/bar is removed via pathrm()
  
  =head4 $ForcePth
  
  Default is false. When set to true it calls pathempty() before any directories are removed to empty the directory so it can be rmdir()'ed when $RemvBase is in effect.
  
  =head2 Creating and Removing Paths
  
  =head3 $NoFtlPth
  
  Default is false. If set to true  rmdir(), mkdir(), and pathempty() calls in pathrm() and pathmk() do not return() on failure.
  
  If its set to true they just silently go about their business regardless. This isn't a good idea but its there if you want it.
  
  =head3 $DirPerms
  
  Mode to pass to any mkdir() calls. Defaults to 0777 as per umask()'s POD. Explicitly having this allows older perls to be able to use FCR and might add a bit of flexibility for you.
  
  Any value you set it to should be suitable for oct()
  
  =head3 Path functions
  
  These functions exist soley because they were necessary for the move and copy functions to have the features they do and not because they are of themselves the purpose of this module. That being said, here is how they work so you can understand how the copy and move funtions work and use them by themselves if you wish.
  
  =head4 pathrm()
  
  Removes a given path recursively. It removes the *entire* path so be carefull!!!
  
  Returns 2 if the given path is not a directory.
  
    File::Copy::Recursive::pathrm('foo/bar/baz') or die $!;
    # foo no longer exists
  
  Same as:
  
    rmdir 'foo/bar/baz' or die $!;
    rmdir 'foo/bar' or die $!;
    rmdir 'foo' or die $!;
  
  An optional second argument makes it call pathempty() before any rmdir()'s when set to true.
  
    File::Copy::Recursive::pathrm('foo/bar/baz', 1) or die $!;
    # foo no longer exists
  
  Same as:PFSCheck
  
    File::Copy::Recursive::pathempty('foo/bar/baz') or die $!;
    rmdir 'foo/bar/baz' or die $!;
    File::Copy::Recursive::pathempty('foo/bar/') or die $!;
    rmdir 'foo/bar' or die $!;
    File::Copy::Recursive::pathempty('foo/') or die $!;
    rmdir 'foo' or die $!;
  
  An optional third argument acts like $File::Copy::Recursive::NoFtlPth, again probably not a good idea.
  
  =head4 pathempty()
  
  Recursively removes the given directory's contents so it is empty. returns 2 if argument is not a directory, 1 on successfully emptying the directory.
  
     File::Copy::Recursive::pathempty($pth) or die $!;
     # $pth is now an empty directory
  
  =head4 pathmk()
  
  Creates a given path recursively. Creates foo/bar/baz even if foo does not exist.
  
     File::Copy::Recursive::pathmk('foo/bar/baz') or die $!;
  
  An optional second argument if true acts just like $File::Copy::Recursive::NoFtlPth, which means you'd never get your die() if something went wrong. Again, probably a *bad* idea.
  
  =head4 pathrmdir()
  
  Same as rmdir() but it calls pathempty() first to recursively empty it first since rmdir can not remove a directory with contents.
  Just removes the top directory the path given instead of the entire path like pathrm(). Return 2 if given argument does not exist (IE its already gone). Return false if it exists but is not a directory.
  
  =head2 Preserving Mode
  
  By default a quiet attempt is made to change the new file or directory to the mode of the old one.
  To turn this behavior off set
    $File::Copy::Recursive::KeepMode
  to false;
  
  =head2 Managing Depth
  
  You can set the maximum depth a directory structure is recursed by setting:
    $File::Copy::Recursive::MaxDepth 
  to a whole number greater than 0.
  
  =head2 SymLinks
  
  If your system supports symlinks then symlinks will be copied as symlinks instead of as the target file.
  Perl's symlink() is used instead of File::Copy's copy()
  You can customize this behavior by setting $File::Copy::Recursive::CopyLink to a true or false value.
  It is already set to true or false dending on your system's support of symlinks so you can check it with an if statement to see how it will behave:
  
      if($File::Copy::Recursive::CopyLink) {
          print "Symlinks will be preserved\n";
      } else {
          print "Symlinks will not be preserved because your system does not support it\n";
      }
  
  If symlinks are being copied you can set $File::Copy::Recursive::BdTrgWrn to true to make it carp when it copies a link whose target does not exist. Its false by default.
  
      local $File::Copy::Recursive::BdTrgWrn  = 1;
  
  =head2 Removing existing target file or directory before copying.
  
  This can be done by setting $File::Copy::Recursive::RMTrgFil or $File::Copy::Recursive::RMTrgDir for file or directory behavior respectively.
  
  0 = off (This is the default)
  
  1 = carp() $! if removal fails
  
  2 = return if removal fails
  
      local $File::Copy::Recursive::RMTrgFil = 1;
      fcopy($orig, $target) or die $!;
      # if it fails it does warn() and keeps going
  
      local $File::Copy::Recursive::RMTrgDir = 2;
      dircopy($orig, $target) or die $!;
      # if it fails it does your "or die"
  
  This should be unnecessary most of the time but its there if you need it :)
  
  =head2 Turning off stat() check
  
  By default the files or directories are checked to see if they are the same (IE linked, or two paths (absolute/relative or different relative paths) to the same file) by comparing the file's stat() info. 
  It's a very efficient check that croaks if they are and shouldn't be turned off but if you must for some weird reason just set $File::Copy::Recursive::PFSCheck to a false value. ("PFS" stands for "Physical File System")
  
  =head2 Emulating cp -rf dir1/ dir2/
  
  By default dircopy($dir1,$dir2) will put $dir1's contents right into $dir2 whether $dir2 exists or not.
  
  You can make dircopy() emulate cp -rf by setting $File::Copy::Recursive::CPRFComp to true.
  
  NOTE: This only emulates -f in the sense that it does not prompt. It does not remove the target file or directory if it exists.
  If you need to do that then use the variables $RMTrgFil and $RMTrgDir described in "Removing existing target file or directory before copying" above.
  
  That means that if $dir2 exists it puts the contents into $dir2/$dir1 instead of $dir2 just like cp -rf.
  If $dir2 does not exist then the contents go into $dir2 like normal (also like cp -rf)
  
  So assuming 'foo/file':
  
      dircopy('foo', 'bar') or die $!;
      # if bar does not exist the result is bar/file
      # if bar does exist the result is bar/file
  
      $File::Copy::Recursive::CPRFComp = 1;
      dircopy('foo', 'bar') or die $!;
      # if bar does not exist the result is bar/file
      # if bar does exist the result is bar/foo/file
  
  You can also specify a star for cp -rf glob type behavior:
  
      dircopy('foo/*', 'bar') or die $!;
      # if bar does not exist the result is bar/file
      # if bar does exist the result is bar/file
  
      $File::Copy::Recursive::CPRFComp = 1;
      dircopy('foo/*', 'bar') or die $!;
      # if bar does not exist the result is bar/file
      # if bar does exist the result is bar/file
  
  NOTE: The '*' is only like cp -rf foo/* and *DOES NOT EXPAND PARTIAL DIRECTORY NAMES LIKE YOUR SHELL DOES* (IE not like cp -rf fo* to copy foo/*)
  
  =head2 Allowing Copy Loops
  
  If you want to allow:
  
    cp -rf . foo/
  
  type behavior set $File::Copy::Recursive::CopyLoop to true.
  
  This is false by default so that a check is done to see if the source directory will contain the target directory and croaks to avoid this problem.
  
  If you ever find a situation where $CopyLoop = 1 is desirable let me know (IE its a bad bad idea but is there if you want it)
  
  (Note: On Windows this was necessary since it uses stat() to detemine samedness and stat() is essencially useless for this on Windows. 
  The test is now simply skipped on Windows but I'd rather have an actual reliable check if anyone in Microsoft land would care to share)
  
  =head1 SEE ALSO
  
  L<File::Copy> L<File::Spec>
  
  =head1 TO DO
  
  I am currently working on and reviewing some other modules to use in the new interface so we can lose the horrid globals as well as some other undesirable traits and also more easily make available some long standing requests.
  
  Tests will be easier to do with the new interface and hence the testing focus will shift to the new interface and aim to be comprehensive.
  
  The old interface will work, it just won't be brought in until it is used, so it will add no overhead for users of the new interface.
  
  I'll add this after the latest verision has been out for a while with no new features or issues found :)
  
  =head1 AUTHOR
  
  Daniel Muey, L<http://drmuey.com/cpan_contact.pl>
  
  =head1 COPYRIGHT AND LICENSE
  
  Copyright 2004 by Daniel Muey
  
  This library is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself. 
  
  =cut
FILE_COPY_RECURSIVE

$fatpacked{"IPC/System/Simple.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'IPC_SYSTEM_SIMPLE';
  package IPC::System::Simple;
  
  # ABSTRACT: Run commands simply, with detailed diagnostics
  
  use 5.006;
  use strict;
  use warnings;
  use re 'taint';
  use Carp;
  use List::Util qw(first);
  use Scalar::Util qw(tainted);
  use Config;
  use constant WINDOWS => ($^O eq 'MSWin32');
  use constant VMS     => ($^O eq 'VMS');
  
  BEGIN {
  
      # It would be lovely to use the 'if' module here, but it didn't
      # enter core until 5.6.2, and we want to keep 5.6.0 compatibility.
  
  
      if (WINDOWS) {
  
          ## no critic (ProhibitStringyEval)
  
          eval q{
              use Win32::Process qw(INFINITE NORMAL_PRIORITY_CLASS);
              use File::Spec;
              use Win32;
  
              # This uses the same rules as the core win32.c/get_shell() call.
  
              use constant WINDOWS_SHELL => eval { Win32::IsWinNT() }
                                              ? [ qw(cmd.exe /x/d/c) ]
                                              : [ qw(command.com /c) ];
  
              # These are used when invoking _win32_capture
              use constant NO_SHELL  => 0;
              use constant USE_SHELL => 1;
  
          };
  
          ## use critic
  
          # Die nosily if any of the above broke.
          die $@ if $@;
      }
  }
  
  # Note that we don't use WIFSTOPPED because perl never uses
  # the WUNTRACED flag, and hence will never return early from
  # system() if the child processes is suspended with a SIGSTOP.
  
  use POSIX qw(WIFEXITED WEXITSTATUS WIFSIGNALED WTERMSIG);
  
  use constant FAIL_START     => q{"%s" failed to start: "%s"};
  use constant FAIL_PLUMBING  => q{Error in IPC::System::Simple plumbing: "%s" - "%s"};
  use constant FAIL_CMD_BLANK => q{Entirely blank command passed: "%s"};
  use constant FAIL_INTERNAL  => q{Internal error in IPC::System::Simple: "%s"};
  use constant FAIL_TAINT     => q{%s called with tainted argument "%s"};
  use constant FAIL_TAINT_ENV => q{%s called with tainted environment $ENV{%s}};
  use constant FAIL_SIGNAL    => q{"%s" died to signal "%s" (%d)%s};
  use constant FAIL_BADEXIT   => q{"%s" unexpectedly returned exit value %d};
  
  use constant FAIL_UNDEF     => q{%s called with undefined command};
  
  use constant FAIL_POSIX     => q{IPC::System::Simple does not understand the POSIX error '%s'.  Please check http://search.cpan.org/perldoc?IPC::System::Simple to see if there is an updated version.  If not please report this as a bug to http://rt.cpan.org/Public/Bug/Report.html?Queue=IPC-System-Simple};
  
  # On Perl's older than 5.8.x we can't assume that there'll be a
  # $^{TAINT} for us to check, so we assume that our args may always
  # be tainted.
  use constant ASSUME_TAINTED => ($] < 5.008);
  
  use constant EXIT_ANY_CONST => -1;			# Used internally
  use constant EXIT_ANY       => [ EXIT_ANY_CONST ];	# Exported
  
  use constant UNDEFINED_POSIX_RE => qr{not (?:defined|a valid) POSIX macro|not implemented on this architecture};
  
  require Exporter;
  our @ISA = qw(Exporter);
  
  our @EXPORT_OK = qw( 
      capture  capturex
      run      runx
      system   systemx
      $EXITVAL EXIT_ANY
  );
  
  our $VERSION = '1.25'; # VERSION : From dzil
  our $EXITVAL = -1;
  
  my @Signal_from_number = split(' ', $Config{sig_name});
  
  # Environment variables we don't want to see tainted.
  my @Check_tainted_env = qw(PATH IFS CDPATH ENV BASH_ENV);
  if (WINDOWS) {
  	push(@Check_tainted_env, 'PERL5SHELL');
  }
  if (VMS) {
  	push(@Check_tainted_env, 'DCL$PATH');
  }
  
  # Not all systems implement the WIFEXITED calls, but POSIX
  # will always export them (even if they're just stubs that
  # die with an error).  Test for the presence of a working
  # WIFEXITED and friends, or define our own.
  
  eval { WIFEXITED(0); };
  
  if ($@ =~ UNDEFINED_POSIX_RE) {
          no warnings 'redefine';  ## no critic
  	*WIFEXITED   = sub { not $_[0] & 0xff };
  	*WEXITSTATUS = sub { $_[0] >> 8  };
  	*WIFSIGNALED = sub { $_[0] & 127 };
  	*WTERMSIG    = sub { $_[0] & 127 };
  } elsif ($@) {
  	croak sprintf FAIL_POSIX, $@;
  }
  
  # None of the POSIX modules I've found define WCOREDUMP, although
  # many systems define it.  Check the POSIX module in the hope that
  # it may actually be there.
  
  
  # TODO: Ideally, $NATIVE_WCOREDUMP should be a constant.
  
  my $NATIVE_WCOREDUMP;
  
  eval { POSIX::WCOREDUMP(1); };
  
  if ($@ =~ UNDEFINED_POSIX_RE) {
  	*WCOREDUMP = sub { $_[0] & 128 };
          $NATIVE_WCOREDUMP = 0;
  } elsif ($@) {
  	croak sprintf FAIL_POSIX, $@;
  } else {
  	# POSIX actually has it defined!  Huzzah!
  	*WCOREDUMP = \&POSIX::WCOREDUMP;
          $NATIVE_WCOREDUMP = 1;
  }
  
  sub _native_wcoredump {
      return $NATIVE_WCOREDUMP;
  }
  
  # system simply calls run
  
  *system  = \&run;
  *systemx = \&runx;
  
  # run is our way of running a process with system() semantics
  
  sub run {
  
  	_check_taint(@_);
  
  	my ($valid_returns, $command, @args) = _process_args(@_);
  
          # If we have arguments, we really want to call systemx,
          # so we do so.
  
  	if (@args) {
                  return systemx($valid_returns, $command, @args);
  	}
  
          # Without arguments, we're calling system, and checking
          # the results.
  
  	# We're throwing our own exception on command not found, so
  	# we don't need a warning from Perl.
  
          {
              # silence 'Statement unlikely to be reached' warning
              no warnings 'exec';             ## no critic
              CORE::system($command,@args);
          }
  
  	return _process_child_error($?,$command,$valid_returns);
  }
  
  # runx is just like system/run, but *never* invokes the shell.
  
  sub runx {
      _check_taint(@_);
  
      my ($valid_returns, $command, @args) = _process_args(@_);
  
      if (WINDOWS) {
          our $EXITVAL = -1;
  
          my $pid = _spawn_or_die($command, "$command @args");
  
          $pid->Wait(INFINITE);	# Wait for process exit.
          $pid->GetExitCode($EXITVAL);
          return _check_exit($command,$EXITVAL,$valid_returns);
      }
  
      # If system() fails, we throw our own exception.  We don't
      # need to have perl complain about it too.
  
      no warnings; ## no critic
  
      CORE::system { $command } $command, @args;
  
      return _process_child_error($?, $command, $valid_returns);
  }
  
  # capture is our way of running a process with backticks/qx semantics
  
  sub capture {
  	_check_taint(@_);
  
  	my ($valid_returns, $command, @args) = _process_args(@_);
  
          if (@args) {
              return capturex($valid_returns, $command, @args);
          }
  
          if (WINDOWS) {
              # USE_SHELL really means "You may use the shell if you need it."
              return _win32_capture(USE_SHELL, $valid_returns, $command, @args);
          }
  
  	our $EXITVAL = -1;
  
  	my $wantarray = wantarray();
  
  	# We'll produce our own warnings on failure to execute.
  	no warnings 'exec';	## no critic
  
          if ($wantarray) {
                  my @results = qx($command);
                  _process_child_error($?,$command,$valid_returns);
                  return @results;
          } 
  
          my $results = qx($command);
          _process_child_error($?,$command,$valid_returns);
          return $results;
  }
  
  # _win32_capture implements the capture and capurex commands on Win32.
  # We need to wrap the whole internals of this sub into
  # an if (WINDOWS) block to avoid it being compiled on non-Win32 systems.
  
  sub _win32_capture {
      if (not WINDOWS) {
          croak sprintf(FAIL_INTERNAL, "_win32_capture called when not under Win32");
      } else {
  
          my ($use_shell, $valid_returns, $command, @args) = @_;
  
          my $wantarray = wantarray();
  
          # Perl doesn't support multi-arg open under
          # Windows.  Perl also doesn't provide very good
          # feedback when normal backtails fail, either;
          # it returns exit status from the shell
          # (which is indistinguishable from the command
          # running and producing the same exit status).
  
          # As such, we essentially have to write our own
          # backticks.
  
          # We start by dup'ing STDOUT.
  
          open(my $saved_stdout, '>&', \*STDOUT)  ## no critic
                  or croak sprintf(FAIL_PLUMBING, "Can't dup STDOUT", $!);
  
          # We now open up a pipe that will allow us to	
          # communicate with the new process.
  
          pipe(my ($read_fh, $write_fh))
                  or croak sprintf(FAIL_PLUMBING, "Can't create pipe", $!);
  
          # Allow CRLF sequences to become "\n", since
          # this is what Perl backticks do.
  
          binmode($read_fh, ':crlf');
  
          # Now we re-open our STDOUT to $write_fh...
  
          open(STDOUT, '>&', $write_fh)  ## no critic
                  or croak sprintf(FAIL_PLUMBING, "Can't redirect STDOUT", $!);
  
          # If we have args, or we're told not to use the shell, then
          # we treat $command as our shell.  Otherwise we grub around
          # in our command to look for a command to run.
          #
          # Note that we don't actually *use* the shell (although in
          # a future version we might).  Being told not to use the shell
          # (capturex) means we treat our command as really being a command,
          # and not a command line.
  
          my $exe =   @args                      ? $command :
                      (! $use_shell)             ? $command :
                      $command =~ m{^"([^"]+)"}x ? $1       :
                      $command =~ m{(\S+)     }x ? $1       :
                      croak sprintf(FAIL_CMD_BLANK, $command);
  
          # And now we spawn our new process with inherited
          # filehandles.
  
          my $err;
          my $pid = eval { 
                  _spawn_or_die($exe, "$command @args"); 
          }
          or do {
                  $err = $@;
          };
  
          # Regardless of whether our command ran, we must restore STDOUT.
          # RT #48319
          open(STDOUT, '>&', $saved_stdout)  ## no critic
                  or croak sprintf(FAIL_PLUMBING,"Can't restore STDOUT", $!);
  
          # And now, if there was an actual error , propagate it.
          die $err if defined $err;   # If there's an error from _spawn_or_die
  
          # Clean-up the filehandles we no longer need...
  
          close($write_fh)
                  or croak sprintf(FAIL_PLUMBING,q{Can't close write end of pipe}, $!);
          close($saved_stdout)
                  or croak sprintf(FAIL_PLUMBING,q{Can't close saved STDOUT}, $!);
  
          # Read the data from our child...
  
          my (@results, $result);
  
          if ($wantarray) {
                  @results = <$read_fh>;
          } else {
                  $result = join("",<$read_fh>);
          }
  
          # Tidy up our windows process and we're done!
  
          $pid->Wait(INFINITE);	# Wait for process exit.
          $pid->GetExitCode($EXITVAL);
  
          _check_exit($command,$EXITVAL,$valid_returns);
  
          return $wantarray ? @results : $result;
  
      }
  }
  
  # capturex() is just like backticks/qx, but never invokes the shell.
  
  sub capturex {
  	_check_taint(@_);
  
  	my ($valid_returns, $command, @args) = _process_args(@_);
  
  	our $EXITVAL = -1;
  
  	my $wantarray = wantarray();
  
  	if (WINDOWS) {
              return _win32_capture(NO_SHELL, $valid_returns, $command, @args);
          }
  
  	# We can't use a multi-arg piped open here, since 5.6.x
  	# doesn't like them.  Instead we emulate what 5.8.x does,
  	# which is to create a pipe(), set the close-on-exec flag
  	# on the child, and the fork/exec.  If the exec fails, the
  	# child writes to the pipe.  If the exec succeeds, then
  	# the pipe closes without data.
  
  	pipe(my ($read_fh, $write_fh))
  		or croak sprintf(FAIL_PLUMBING, "Can't create pipe", $!);
  
  	# This next line also does an implicit fork.
  	my $pid = open(my $pipe, '-|');	 ## no critic
  
  	if (not defined $pid) {
  		croak sprintf(FAIL_START, $command, $!);
  	} elsif (not $pid) {
  		# Child process, execs command.
  
  		close($read_fh);
  
  		# TODO: 'no warnings exec' doesn't get rid
  		# of the 'unlikely to be reached' warnings.
  		# This is a bug in perl / perldiag / perllexwarn / warnings.
  
  		no warnings;   ## no critic
  
  		CORE::exec { $command } $command, @args;
  
  		# Oh no, exec fails!  Send the reason why to
  		# the parent.
  
  		print {$write_fh} int($!);
  		exit(-1);
  	}
  
  	{
  		# In parent process.
  
  		close($write_fh);
  
  		# Parent process, check for child error.
  		my $error = <$read_fh>;
  
  		# Tidy up our pipes.
  		close($read_fh);
  
  		# Check for error.
  		if ($error) {
  			# Setting $! to our child error number gives
  			# us nice looking strings when printed.
  			local $! = $error;
  			croak sprintf(FAIL_START, $command, $!);
  		}
  	}
  
  	# Parent process, we don't care about our pid, but we
  	# do go and read our pipe.
  
  	if ($wantarray) {
  		my @results = <$pipe>;
  		close($pipe);
  		_process_child_error($?,$command,$valid_returns);
  		return @results;
  	}
  
  	# NB: We don't check the return status on close(), since
  	# on failure it sets $?, which we then inspect for more
  	# useful information.
  
  	my $results = join("",<$pipe>);
  	close($pipe);
  	_process_child_error($?,$command,$valid_returns);
  	
  	return $results;
  
  }
  
  # Tries really hard to spawn a process under Windows.  Returns
  # the pid on success, or undef on error.
  
  sub _spawn_or_die {
  
  	# We need to wrap practically the entire sub in an
  	# if block to ensure it doesn't get compiled under non-Win32
  	# systems.  Compiling on these systems would not only be a
  	# waste of time, but also results in complaints about
  	# the NORMAL_PRIORITY_CLASS constant.
  
  	if (not WINDOWS) {
  		croak sprintf(FAIL_INTERNAL, "_spawn_or_die called when not under Win32");
  	} else {
  		my ($orig_exe, $cmdline) = @_;
  		my $pid;
  
  		my $exe = $orig_exe;
  
  		# If our command doesn't have an extension, add one.
  		$exe .= $Config{_exe} if ($exe !~ m{\.});
  
  		Win32::Process::Create(
  			$pid, $exe, $cmdline, 1, NORMAL_PRIORITY_CLASS, "."
  		) and return $pid;
  
  		my @path = split(/;/,$ENV{PATH});
  
  		foreach my $dir (@path) {
  			my $fullpath = File::Spec->catfile($dir,$exe);
  
  			# We're using -x here on the assumption that stat()
  			# is faster than spawn, so trying to spawn a process
  			# for each path element will be unacceptably
  			# inefficient.
  
  			if (-x $fullpath) {
  				Win32::Process::Create(
  					$pid, $fullpath, $cmdline, 1,
  					NORMAL_PRIORITY_CLASS, "."
  				) and return $pid;
  			}
  		}
  
  		croak sprintf(FAIL_START, $orig_exe, $^E);
  	}
  }
  
  # Complain on tainted arguments or environment.
  # ASSUME_TAINTED is true for 5.6.x, since it's missing ${^TAINT}
  
  sub _check_taint {
  	return if not (ASSUME_TAINTED or ${^TAINT});
  	my $caller = (caller(1))[3];
  	foreach my $var (@_) {
  		if (tainted $var) {
  			croak sprintf(FAIL_TAINT, $caller, $var);
  		}
  	}
  	foreach my $var (@Check_tainted_env) {
  		if (tainted $ENV{$var} ) {
  			croak sprintf(FAIL_TAINT_ENV, $caller, $var);
  		}
  	}
  
  	return;
  
  }
  
  # This subroutine performs the difficult task of interpreting
  # $?.  It's not intended to be called directly, as it will
  # croak on errors, and its implementation and interface may
  # change in the future.
  
  sub _process_child_error {
  	my ($child_error, $command, $valid_returns) = @_;
  	
  	$EXITVAL = -1;
  
  	my $coredump = WCOREDUMP($child_error);
  
          # There's a bug in perl 5.10.0 where if the system
          # does not provide a native WCOREDUMP, then $? will
          # never contain coredump information.  This code
          # checks to see if we have the bug, and works around
          # it if needed.
  
          if ($] >= 5.010 and not $NATIVE_WCOREDUMP) {
              $coredump ||= WCOREDUMP( ${^CHILD_ERROR_NATIVE} );
          }
  
  	if ($child_error == -1) {
  		croak sprintf(FAIL_START, $command, $!);
  
  	} elsif ( WIFEXITED( $child_error ) ) {
  		$EXITVAL = WEXITSTATUS( $child_error );
  
  		return _check_exit($command,$EXITVAL,$valid_returns);
  
  	} elsif ( WIFSIGNALED( $child_error ) ) {
  		my $signal_no   = WTERMSIG( $child_error );
  		my $signal_name = $Signal_from_number[$signal_no] || "UNKNOWN";
  
  		croak sprintf FAIL_SIGNAL, $command, $signal_name, $signal_no, ($coredump ? " and dumped core" : "");
  
  
  	} 
  
  	croak sprintf(FAIL_INTERNAL, qq{'$command' ran without exit value or signal});
  
  }
  
  # A simple subroutine for checking exit values.  Results in better
  # assurance of consistent error messages, and better forward support
  # for new features in I::S::S.
  
  sub _check_exit {
  	my ($command, $exitval, $valid_returns) = @_;
  
  	# If we have a single-value list consisting of the EXIT_ANY
  	# value, then we're happy with whatever exit value we're given.
  	if (@$valid_returns == 1 and $valid_returns->[0] == EXIT_ANY_CONST) {
  		return $exitval;
  	}
  
  	if (not defined first { $_ == $exitval } @$valid_returns) {
  		croak sprintf FAIL_BADEXIT, $command, $exitval;
  	}	
  	return $exitval;
  }
  
  
  # This subroutine simply determines a list of valid returns, the command
  # name, and any arguments that we need to pass to it.
  
  sub _process_args {
  	my $valid_returns = [ 0 ];
  	my $caller = (caller(1))[3];
  
  	if (not @_) {
  		croak "$caller called with no arguments";
  	}
  
  	if (ref $_[0] eq "ARRAY") {
  		$valid_returns = shift(@_);
  	}
  
  	if (not @_) {
  		croak "$caller called with no command";
  	}
  
  	my $command = shift(@_);
  
          if (not defined $command) {
                  croak sprintf( FAIL_UNDEF, $caller );
          }
  
  	return ($valid_returns,$command,@_);
  
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  IPC::System::Simple - Run commands simply, with detailed diagnostics
  
  =head1 SYNOPSIS
  
    use IPC::System::Simple qw(system systemx capture capturex);
  
    system("some_command");        # Command succeeds or dies!
  
    system("some_command",@args);  # Succeeds or dies, avoids shell if @args
  
    systemx("some_command",@args); # Succeeds or dies, NEVER uses the shell
  
  
    # Capture the output of a command (just like backticks). Dies on error.
    my $output = capture("some_command");
  
    # Just like backticks in list context.  Dies on error.
    my @output = capture("some_command");
  
    # As above, but avoids the shell if @args is non-empty
    my $output = capture("some_command", @args);
  
    # As above, but NEVER invokes the shell.
    my $output = capturex("some_command", @args);
    my @output = capturex("some_command", @args);
  
  =head1 DESCRIPTION
  
  Calling Perl's in-built C<system()> function is easy, 
  determining if it was successful is I<hard>.  Let's face it,
  C<$?> isn't the nicest variable in the world to play with, and
  even if you I<do> check it, producing a well-formatted error
  string takes a lot of work.
  
  C<IPC::System::Simple> takes the hard work out of calling 
  external commands.  In fact, if you want to be really lazy,
  you can just write:
  
      use IPC::System::Simple qw(system);
  
  and all of your C<system> commands will either succeed (run to
  completion and return a zero exit value), or die with rich diagnostic
  messages.
  
  The C<IPC::System::Simple> module also provides a simple replacement
  to Perl's backticks operator.  Simply write:
  
      use IPC::System::Simple qw(capture);
  
  and then use the L</capture()> command just like you'd use backticks.
  If there's an error, it will die with a detailed description of what
  went wrong.  Better still, you can even use C<capturex()> to run the
  equivalent of backticks, but without the shell:
  
      use IPC::System::Simple qw(capturex);
  
      my $result = capturex($command, @args);
  
  If you want more power than the basic interface, including the
  ability to specify which exit values are acceptable, trap errors,
  or process diagnostics, then read on!
  
  =head1 ADVANCED SYNOPSIS
  
    use IPC::System::Simple qw(
      capture capturex system systemx run runx $EXITVAL EXIT_ANY
    );
  
    # Run a command, throwing exception on failure
  
    run("some_command");
  
    runx("some_command",@args);  # Run a command, avoiding the shell
  
    # Do the same thing, but with the drop-in system replacement.
  
    system("some_command");
  
    systemx("some_command", @args);
  
    # Run a command which must return 0..5, avoid the shell, and get the
    # exit value (we could also look at $EXITVAL)
  
    my $exit_value = runx([0..5], "some_command", @args);
  
    # The same, but any exit value will do.
  
    my $exit_value = runx(EXIT_ANY, "some_command", @args);
  
    # Capture output into $result and throw exception on failure
  
    my $result = capture("some_command");	
  
    # Check exit value from captured command
  
    print "some_command exited with status $EXITVAL\n";
  
    # Captures into @lines, splitting on $/
    my @lines = capture("some_command"); 
  
    # Run a command which must return 0..5, capture the output into
    # @lines, and avoid the shell.
  
    my @lines  = capturex([0..5], "some_command", @args);
  
  =head1 ADVANCED USAGE
  
  =head2 run() and system()
  
  C<IPC::System::Simple> provides a subroutine called
  C<run>, that executes a command using the same semantics is
  Perl's built-in C<system>:
  
      use IPC::System::Simple qw(run);
  
      run("cat *.txt");           # Execute command via the shell
      run("cat","/etc/motd");     # Execute command without shell
  
  The primary difference between Perl's in-built system and
  the C<run> command is that C<run> will throw an exception on
  failure, and allows a list of acceptable exit values to be set.
  See L</Exit values> for further information.
  
  In fact, you can even have C<IPC::System::Simple> replace the
  default C<system> function for your package so it has the
  same behaviour:
  
      use IPC::System::Simple qw(system);
  
      system("cat *.txt");  # system now suceeds or dies!
  
  C<system> and C<run> are aliases to each other.
  
  See also L</runx(), systemx() and capturex()> for variants of
  C<system()> and C<run()> that never invoke the shell, even with
  a single argument.
  
  =head2 capture()
  
  A second subroutine, named C<capture> executes a command with
  the same semantics as Perl's built-in backticks (and C<qx()>):
  
      use IPC::System::Simple qw(capture);
  
      # Capture text while invoking the shell.
      my $file  = capture("cat /etc/motd");
      my @lines = capture("cat /etc/passwd");
  
  However unlike regular backticks, which always use the shell, C<capture>
  will bypass the shell when called with multiple arguments:
  
      # Capture text while avoiding the shell.
      my $file  = capture("cat", "/etc/motd");
      my @lines = capture("cat", "/etc/passwd");
  
  See also L</runx(), systemx() and capturex()> for a variant of
  C<capture()> that never invokes the shell, even with a single
  argument.
  
  =head2 runx(), systemx() and capturex()
  
  The C<runx()>, C<systemx()> and C<capturex()> commands are identical
  to the multi-argument forms of C<run()>, C<system()> and C<capture()>
  respectively, but I<never> invoke the shell, even when called with a
  single argument.  These forms are particularly useful when a command's
  argument list I<might> be empty, for example:
  
      systemx($cmd, @args);
  
  The use of C<systemx()> here guarantees that the shell will I<never>
  be invoked, even if C<@args> is empty.
  
  =head2 Exception handling
  
  In the case where the command returns an unexpected status, both C<run> and
  C<capture> will throw an exception, which if not caught will terminate your
  program with an error.
  
  Capturing the exception is easy:
  
      eval {
          run("cat *.txt");
      };
  
      if ($@) {
          print "Something went wrong - $@\n";
      }
  
  See the diagnostics section below for more details.
  
  =head3 Exception cases
  
  C<IPC::System::Simple> considers the following to be unexpected,
  and worthy of exception:
  
  =over 4
  
  =item *
  
  Failing to start entirely (eg, command not found, permission denied).
  
  =item *
  
  Returning an exit value other than zero (but see below).
  
  =item *
  
  Being killed by a signal.
  
  =item *
  
  Being passed tainted data (in taint mode).
  
  =back
  
  =head2 Exit values
  
  Traditionally, system commands return a zero status for success and a
  non-zero status for failure.  C<IPC::System::Simple> will default to throwing
  an exception if a non-zero exit value is returned.
  
  You may specify a range of values which are considered acceptable exit
  values by passing an I<array reference> as the first argument.  The
  special constant C<EXIT_ANY> can be used to allow I<any> exit value
  to be returned.
  
  	use IPC::System::Simple qw(run system capture EXIT_ANY);
  
  	run( [0..5], "cat *.txt");             # Exit values 0-5 are OK
  
  	system( [0..5], "cat *.txt");          # This works the same way
  
  	my @lines = capture( EXIT_ANY, "cat *.txt"); # Any exit is fine.
  
  The C<run> and replacement C<system> subroutines returns the exit
  value of the process:
  
  	my $exit_value = run( [0..5], "cat *.txt");
  
  	# OR:
  
  	my $exit_value = system( [0..5] "cat *.txt");
  
  	print "Program exited with value $exit_value\n";
  
  =head3 $EXITVAL
  
  The exit value of any command executed by C<IPC::System::Simple>
  can always be retrieved from the C<$IPC::System::Simple::EXITVAL>
  variable:
  
  This is particularly useful when inspecting results from C<capture>,
  which returns the captured text from the command.
  
  	use IPC::System::Simple qw(capture $EXITVAL EXIT_ANY);
  
  	my @enemies_defeated = capture(EXIT_ANY, "defeat_evil", "/dev/mordor");
  
  	print "Program exited with value $EXITVAL\n";
  
  C<$EXITVAL> will be set to C<-1> if the command did not exit normally (eg,
  being terminated by a signal) or did not start.  In this situation an
  exception will also be thrown.
  
  =head2 WINDOWS-SPECIFIC NOTES
  
  As of C<IPC::System::Simple> v0.06, the C<run> subroutine I<when
  called with multiple arguments> will make available the full 32-bit
  exit value on Win32 systems.  This is different from the
  previous versions of C<IPC::System::Simple> and from Perl's
  in-build C<system()> function, which can only handle 8-bit return values.
  
  The C<capture> subroutine always returns the 32-bit exit value under
  Windows.  The C<capture> subroutine also never uses the shell,
  even when passed a single argument.
  
  Versions of C<IPC::System::Simple> before v0.09 would not search
  the C<PATH> environment variable when the multi-argument form of
  C<run()> was called.  Versions from v0.09 onwards correctly search
  the path provided the command is provided including the extension
  (eg, C<notepad.exe> rather than just C<notepad>, or C<gvim.bat> rather
  than just C<gvim>).  If no extension is provided, C<.exe> is
  assumed.
  
  Signals are not supported on Windows systems.  Sending a signal
  to a Windows process will usually cause it to exit with the signal
  number used.
  
  =head1 DIAGNOSTICS
  
  =over 4
  
  =item "%s" failed to start: "%s"
  
  The command specified did not even start.  It may not exist, or
  you may not have permission to use it.  The reason it could not
  start (as determined from C<$!>) will be provided.
  
  =item "%s" unexpectedly returned exit value %d
  
  The command ran successfully, but returned an exit value we did
  not expect.  The value returned is reported.
  
  =item "%s" died to signal "%s" (%d) %s
  
  The command was killed by a signal.  The name of the signal
  will be reported, or C<UNKNOWN> if it cannot be determined.  The
  signal number is always reported.  If we detected that the
  process dumped core, then the string C<and dumped core> is
  appended.
  
  =item IPC::System::Simple::%s called with no arguments
  
  You attempted to call C<run> or C<capture> but did not provide any
  arguments at all.  At the very lease you need to supply a command
  to run.
  
  =item IPC::System::Simple::%s called with no command
  
  You called C<run> or C<capture> with a list of acceptable exit values,
  but no actual command.
  
  =item IPC::System::Simple::%s called with tainted argument "%s"
  
  You called C<run> or C<capture> with tainted (untrusted) arguments, which is
  almost certainly a bad idea.  To untaint your arguments you'll need to pass
  your data through a regular expression and use the resulting match variables.
  See L<perlsec/Laundering and Detecting Tainted Data> for more information.
  
  =item IPC::System::Simple::%s called with tainted environment $ENV{%s}
  
  You called C<run> or C<capture> but part of your environment was tainted
  (untrusted).  You should either delete the named environment
  variable before calling C<run>, or set it to an untainted value
  (usually one set inside your program).  See
  L<perlsec/Cleaning Up Your Path> for more information.
  
  =item Error in IPC::System::Simple plumbing: "%s" - "%s"
  
  Implementing the C<capture> command involves dark and terrible magicks
  involving pipes, and one of them has sprung a leak.  This could be due to a
  lack of file descriptors, although there are other possibilities.
  
  If you are able to reproduce this error, you are encouraged
  to submit a bug report according to the L</Reporting bugs> section below.
  
  =item Internal error in IPC::System::Simple: "%s"
  
  You've found a bug in C<IPC::System::Simple>.  Please check to
  see if an updated version of C<IPC::System::Simple> is available.
  If not, please file a bug report according to the L</Reporting bugs> section
  below.
  
  =item IPC::System::Simple::%s called with undefined command
  
  You've passed the undefined value as a command to be executed.
  While this is a very Zen-like action, it's not supported by
  Perl's current implementation.
  
  =back
  
  =head1 DEPENDENCIES
  
  This module depends upon L<Win32::Process> when used on Win32
  system.  C<Win32::Process> is bundled as a core module in ActivePerl 5.6
  and above.
  
  There are no non-core dependencies on non-Win32 systems.
  
  =head1 COMPARISON TO OTHER APIs
  
  Perl provides a range of in-built functions for handling external
  commands, and CPAN provides even more.  The C<IPC::System::Simple>
  differentiates itself from other options by providing:
  
  =over 4
  
  =item Extremely detailed diagnostics
  
  The diagnostics produced by C<IPC::System::Simple> are designed
  to provide as much information as possible.  Rather than requiring
  the developer to inspect C<$?>, C<IPC::System::Simple> does the
  hard work for you.
  
  If an odd exit status is provided, you're informed of what it is.  If
  a signal kills your process, you are informed of both its name and
  number.  If tainted data or environment prevents your command from
  running, you are informed of exactly which datais 
  
  =item Exceptions on failure
  
  C<IPC::System::Simple> takes an aggressive approach to error handling.
  Rather than allow commands to fail silently, exceptions are thrown
  when unexpected results are seen.  This allows for easy development
  using a try/catch style, and avoids the possibility of accidently
  continuing after a failed command.
  
  =item Easy access to exit status
  
  The C<run>, C<system> and C<capture> commands all set C<$EXITVAL>,
  making it easy to determine the exit status of a command.
  Additionally, the C<system> and C<run> interfaces return the exit
  status.
  
  =item Consistent interfaces
  
  When called with multiple arguments, the C<run>, C<system> and
  C<capture> interfaces I<never> invoke the shell.  This differs
  from the in-built Perl C<system> command which may invoke the
  shell under Windows when called with multiple arguments.  It
  differs from the in-built Perl backticks operator which always
  invokes the shell.
  
  =back
  
  =head1 BUGS
  
  When C<system> is exported, the exotic form C<system { $cmd } @args>
  is not supported.  Attemping to use the exotic form is a syntax
  error.  This affects the calling package I<only>.  Use C<CORE::system>
  if you need it, or consider using the L<autodie> module to replace
  C<system> with lexical scope.
  
  Core dumps are only checked for when a process dies due to a
  signal.  It is not believed there are any systems where processes
  can dump core without dying to a signal.
  
  C<WIFSTOPPED> status is not checked, as perl never spawns processes
  with the C<WUNTRACED> option.
  
  Signals are not supported under Win32 systems, since they don't
  work at all like Unix signals.  Win32 singals cause commands to
  exit with a given exit value, which this modules I<does> capture.
  
  Only 8-bit values are returned when C<run()> or C<system()> 
  is called with a single value under Win32.  Multi-argument calls
  to C<run()> and C<system()>, as well as the C<runx()> and
  C<systemx()> always return the 32-bit Windows return values.
  
  =head2 Reporting bugs
  
  Before reporting a bug, please check to ensure you are using the
  most recent version of C<IPC::System::Simple>.  Your problem may
  have already been fixed in a new release.
  
  You can find the C<IPC::System::Simple> bug-tracker at
  L<http://rt.cpan.org/Public/Dist/Display.html?Name=IPC-System-Simple> .
  Please check to see if your bug has already been reported; if
  in doubt, report yours anyway.
  
  Submitting a patch and/or failing test case will greatly expedite
  the fixing of bugs.
  
  =head1 FEEDBACK
  
  If you find this module useful, please consider rating it on the
  CPAN Ratings service at
  L<http://cpanratings.perl.org/rate/?distribution=IPC-System-Simple> .
  
  The module author loves to hear how C<IPC::System::Simple> has made
  your life better (or worse).  Feedback can be sent to
  E<lt>pjf@perltraining.com.auE<gt>.
  
  =head1 SEE ALSO
  
  L<autodie> uses C<IPC::System::Simple> to provide succeed-or-die
  replacements to C<system> (and other built-ins) with lexical scope.
  
  L<POSIX>, L<IPC::Run::Simple>, L<perlipc>, L<perlport>, L<IPC::Run>,
  L<IPC::Run3>, L<Win32::Process>
  
  =head1 AUTHOR
  
  Paul Fenwick E<lt>pjf@cpan.orgE<gt>
  
  =head1 COPYRIGHT AND LICENSE
  
  Copyright (C) 2006-2008 by Paul Fenwick
  
  This library is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself, either Perl version 5.6.0 or,
  at your option, any later version of Perl 5 you may have available.
  
  =for Pod::Coverage WCOREDUMP
  
  =cut
IPC_SYSTEM_SIMPLE

$fatpacked{"autodie/Scope/Guard.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'AUTODIE_SCOPE_GUARD';
  package autodie::Scope::Guard;
  
  use strict;
  use warnings;
  
  # ABSTRACT: Wrapper class for calling subs at end of scope
  our $VERSION = '2.25'; # VERSION
  
  # This code schedules the cleanup of subroutines at the end of
  # scope.  It's directly inspired by chocolateboy's excellent
  # Scope::Guard module.
  
  sub new {
      my ($class, $handler) = @_;
      return bless($handler, $class);
  }
  
  sub DESTROY {
      my ($self) = @_;
  
      $self->();
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  autodie::Scope::Guard - Wrapper class for calling subs at end of scope
  
  =head1 SYNOPSIS
  
      use autodie::Scope::Guard;
      $^H{'my-key'} = autodie::Scope::Guard->new(sub {
          print "Hallo world\n";
      });
  
  =head1 DESCRIPTION
  
  This class is used to bless perl subs so that they are invoked when
  they are destroyed.  This is mostly useful for ensuring the code is
  invoked at end of scope.  This module is not a part of autodie's
  public API.
  
  This module is directly inspired by chocolateboy's excellent
  Scope::Guard module.
  
  =head2 Methods
  
  =head3 new
  
    my $hook = autodie::Scope::Guard->new(sub {});
  
  Creates a new C<autodie::Scope::Guard>, which will invoke the given
  sub once it goes out of scope (i.e. its DESTROY handler is called).
  
  =head1 AUTHOR
  
  Copyright 2008-2009, Paul Fenwick E<lt>pjf@perltraining.com.auE<gt>
  
  =head1 LICENSE
  
  This module is free software.  You may distribute it under the
  same terms as Perl itself.
AUTODIE_SCOPE_GUARD

$fatpacked{"autodie/Scope/GuardStack.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'AUTODIE_SCOPE_GUARDSTACK';
  package autodie::Scope::GuardStack;
  
  use strict;
  use warnings;
  
  use autodie::Scope::Guard;
  
  # ABSTRACT: Hook stack for managing scopes via %^H
  our $VERSION = '2.25'; # VERSION
  
  my $H_KEY_STEM = __PACKAGE__ . '/guard';
  my $COUNTER = 0;
  
  # This code schedules the cleanup of subroutines at the end of
  # scope.  It's directly inspired by chocolateboy's excellent
  # Scope::Guard module.
  
  sub new {
      my ($class) = @_;
  
      return bless([], $class);
  }
  
  sub push_hook {
      my ($self, $hook) = @_;
      my $h_key = $H_KEY_STEM . ($COUNTER++);
      my $size = @{$self};
      $^H{$h_key} = autodie::Scope::Guard->new(sub {
          # Pop the stack until we reach the right size
          # - this may seem weird, but it is to avoid relying
          #   on "destruction order" of keys in %^H.
          #
          # Example:
          #  {
          #     use autodie;  # hook 1
          #     no autodie;   # hook 2
          #     use autodie;  # hook 3
          #  }
          #
          #  Here we want call hook 3, then hook 2 and finally hook 1.
          #  Any other order could have undesired consequences.
          #
          #  Suppose hook 2 is destroyed first, it will pop hook 3 and
          #  then hook 2.  hook 3 will then be destroyed, but do nothing
          #  since its "frame" was already popped and finally hook 1
          #  will be popped and take its own frame with it.
          $self->_pop_hook while @{$self} > $size;
      });
      push(@{$self}, [$hook, $h_key]);
      return;
  }
  
  sub _pop_hook {
      my ($self) = @_;
      my ($hook, $key) = @{ pop(@{$self}) };
      my $ref = delete($^H{$key});
      $hook->();
      return;
  }
  
  sub DESTROY {
      my ($self) = @_;
  
      # To be honest, I suspect @{$self} will always be empty here due
      # to the subs in %^H having references to the stack (which would
      # keep the stack alive until those have been destroyed).  Anyhow,
      # it never hurt to be careful.
      $self->_pop_hook while @{$self};
      return;
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  autodie::Scope::GuardStack -  Hook stack for managing scopes via %^H
  
  =head1 SYNOPSIS
  
      use autodie::Scope::GuardStack;
      my $stack = autodie::Scope::GuardStack->new
      $^H{'my-key'} = $stack;
  
      $stack->push_hook(sub {});
  
  =head1 DESCRIPTION
  
  This class is a stack of hooks to be called in the right order as
  scopes go away.  The stack is only useful when inserted into C<%^H>
  and will pop hooks as their "scope" is popped.  This is useful for
  uninstalling or reinstalling subs in a namespace as a pragma goes
  out of scope.
  
  Due to how C<%^H> works, this class is only useful during the
  compilation phase of a perl module and relies on the internals of how
  perl handles references in C<%^H>.  This module is not a part of
  autodie's public API.
  
  =head2 Methods
  
  =head3 new
  
    my $stack = autodie::Scope::GuardStack->new;
  
  Creates a new C<autodie::Scope::GuardStack>.  The stack is initially
  empty and must be inserted into C<%^H> by the creator.
  
  =head3 push_hook
  
    $stack->push_hook(sub {});
  
  Add a sub to the stack.  The sub will be called once the current
  compile-time "scope" is left.  Multiple hooks can be added per scope
  
  =head1 AUTHOR
  
  Copyright 2013, Niels Thykier E<lt>niels@thykier.netE<gt>
  
  =head1 LICENSE
  
  This module is free software.  You may distribute it under the
  same terms as Perl itself.
AUTODIE_SCOPE_GUARDSTACK

$fatpacked{"autodie/ScopeUtil.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'AUTODIE_SCOPEUTIL';
  package autodie::ScopeUtil;
  
  use strict;
  use warnings;
  
  # Docs say that perl 5.8.3 has Exporter 5.57 and autodie requires
  # 5.8.4, so this should "just work".
  use Exporter 5.57 qw(import);
  
  use autodie::Scope::GuardStack;
  
  our @EXPORT_OK = qw(on_end_of_compile_scope);
  
  # ABSTRACT: Utilities for managing %^H scopes
  our $VERSION = '2.25'; # VERSION
  
  # docs says we should pick __PACKAGE__ /<whatever>
  my $H_STACK_KEY = __PACKAGE__ . '/stack';
  
  sub on_end_of_compile_scope {
      my ($hook) = @_;
  
      # Dark magic to have autodie work under 5.8
      # Copied from namespace::clean, that copied it from
      # autobox, that found it on an ancient scroll written
      # in blood.
  
      # This magic bit causes %^H to be lexically scoped.
      $^H |= 0x020000;
  
      my $stack = $^H{$H_STACK_KEY};
      if (not defined($stack)) {
          $stack = autodie::Scope::GuardStack->new;
          $^H{$H_STACK_KEY} = $stack;
      }
  
      $stack->push_hook($hook);
      return;
  }
  
  1;
  
  =head1 NAME
  
  autodie::ScopeUtil - Utilities for managing %^H scopes
  
  =head1 SYNOPSIS
  
      use autodie::ScopeUtil qw(on_end_of_compile_scope);
      on_end_of_compile_scope(sub { print "Hallo world\n"; });
  
  =head1 DESCRIPTION
  
  Utilities for abstracting away the underlying magic of (ab)using
  C<%^H> to call subs at the end of a (compile-time) scopes.
  
  Due to how C<%^H> works, these utilities are only useful during the
  compilation phase of a perl module and relies on the internals of how
  perl handles references in C<%^H>.  This module is not a part of
  autodie's public API.
  
  =head2 Methods
  
  =head3 on_end_of_compile_scope
  
    on_end_of_compile_scope(sub { print "Hallo world\n"; });
  
  Will invoke a sub at the end of a (compile-time) scope.  The sub is
  called once with no arguments.  Can be called multiple times (even in
  the same "compile-time" scope) to install multiple subs.  Subs are
  called in a "first-in-last-out"-order (FILO or "stack"-order).
  
  =head1 AUTHOR
  
  Copyright 2013, Niels Thykier E<lt>niels@thykier.netE<gt>
  
  =head1 LICENSE
  
  This module is free software.  You may distribute it under the
  same terms as Perl itself.
AUTODIE_SCOPEUTIL

s/^  //mg for values %fatpacked;

my $class = 'FatPacked::'.(0+\%fatpacked);
no strict 'refs';
*{"${class}::files"} = sub { keys %{$_[0]} };

if ($] < 5.008) {
  *{"${class}::INC"} = sub {
     if (my $fat = $_[0]{$_[1]}) {
       return sub {
         return 0 unless length $fat;
         $fat =~ s/^([^\n]*\n?)//;
         $_ = $1;
         return 1;
       };
     }
     return;
  };
}

else {
  *{"${class}::INC"} = sub {
    if (my $fat = $_[0]{$_[1]}) {
      open my $fh, '<', \$fat
        or die "FatPacker error loading $_[1] (could be a perl installation issue?)";
      return $fh;
    }
    return;
  };
}

unshift @INC, bless \%fatpacked, $class;
  } # END OF FATPACK CODE

use 5.010;
use strict;
use warnings;
use autodie qw(:all);
use FindBin qw($Bin);
use File::Path qw(remove_tree);
use IPC::System::Simple qw(systemx capturex);
use File::Spec;
use File::Copy::Recursive qw(rcopy);
use autodie qw(rcopy);
use Fcntl qw(SEEK_SET);

# Simple script to build and repack

my $REPACK  = "CKAN/packages/ILRepack.1.25.0/tools/ILRepack.exe";
my $TARGET  = "Debug";      # Even our releases contain debugging info
my $OUTNAME = "ckan.exe";   # Or just `ckan` if we want to be unixy
my $BUILD   = "$Bin/../build";
my $SOURCE  = "$Bin/../CKAN";
my $METACLASS = "build/CKAN/Meta.cs";

my @PROJECTS = qw(CmdLine CKAN CKAN-GUI NetKAN Tests);

my @BUILD_OPTS = is_stable() ? "/p:DefineConstants=STABLE" : ();

# Make sure we clean any old build away first.
remove_tree($BUILD);

# Copy our project files over.
copy($SOURCE, $BUILD);

# Remove any old build artifacts
foreach my $project (@PROJECTS) {
    remove_tree(File::Spec->catdir($BUILD, "$project/bin"));
    remove_tree(File::Spec->catdir($BUILD, "$project/obj"));
}

# Before we build, see if we can locate a version and add it in.
# Because travis does a shallow clone, we might fail at this in
# dev releases, in which case our build will remain as "development"
# and extra version tests won't run.

my $VERSION = eval { capturex(qw(git describe --tags --long)) };

if ($VERSION) {
    chomp $VERSION;
    set_build($METACLASS, $VERSION);
    add_assembly_version("build/CmdLine/Properties/AssemblyInfo.cs", $VERSION);
}
else {
    warn "No recent tag found, making development build.\n";
}

# Change to our build directory
chdir($BUILD);

# And build..
system("xbuild", "/property:Configuration=$TARGET", @BUILD_OPTS, "/property:win32icon=../assets/ckan.ico", "CKAN.sln");

say "\n\n=== Repacking ===\n\n";

chdir("$Bin/..");

# Repack ckan.exe

my @cmd = (
    "mono",
    $REPACK,
    "--out:ckan.exe",
    "--lib:build/CmdLine/bin/$TARGET",
    "build/CmdLine/bin/$TARGET/CmdLine.exe",
    glob("build/CmdLine/bin/$TARGET/*.dll"),
    "build/CmdLine/bin/$TARGET/CKAN-GUI.exe", # Yes, bundle the .exe as a .dll
);

system([0,1], qq{@cmd | grep -v "Duplicate Win32 resource"});

# Repack netkan

@cmd = (
    "mono",
    $REPACK,
    "--out:netkan.exe",
    "--lib:build/NetKAN/bin/$TARGET",
    "build/NetKAN/bin/$TARGET/NetKAN.exe",
    glob("build/NetKAN/bin/$TARGET/*.dll"),
);

system([0,1], qq{@cmd | grep -v "Duplicate Win32 resource"});

say "\n\n=== Tidying up===\n\n";

# We don't tidy up any more, these provide useful debugging.
# unlink("$OUTNAME.mdb");
# unlink("netkan.exe.mdb");

say "Done!";

# Do an appropriate copy for our system
sub copy {
    my ($src, $dst) = @_;

    if ($^O eq "MSWin32") {
        # Use File::Copy::Recursive under Windows
        rcopy($src, $dst);
    }
    else {
        my @CP;
        if ($^O eq "darwin") {
            # Simple copy for Macs
            @CP = qw(cp -r);
        } else {
            # Use friggin' awesome btrfs magic under Linux.
            # This still works, even without btrfs. :)
            @CP = qw(cp -r --reflink=auto --sparse=always);
        }

        system(@CP,$src,$dst);
    }
    return;
}

# Sets a fancy BUILD_VERSION in the specified file.
sub set_build {
    my ($file, $build) = @_;

    local $/;   # Slurp entire files on read

    open(my $fh, '+<', $file);
    my $contents = <$fh>;

    $contents =~ s{(BUILD_VERSION\s*=\s*)null}{$1"$build"}
        or die "Could not find BUILD_VERSION string";

    # Truncate our file and overwrite with new info
    truncate($fh,0);
    seek($fh,SEEK_SET,0);

    print {$fh} $contents;
    close($fh);
}

# Adds C# compatible version info to the file specified.
sub add_assembly_version {
    my ($file, $build) = @_;

    # Manipulate our build to produce a x.x.x.x format
    if (not $build =~ s/v(\d+\.\d+\.\d+)-(\d+).*/$1.$2/) {
        warn "Can't munge $build cleanly into a x.x.x.x version, skipping\n";
    }

    open(my $fh, '>>', $file);
    say {$fh} qq{[assembly: AssemblyVersion("$build")]};
    close($fh);

    return;
}

sub is_stable {
    my $branch = eval { capturex(qw(git rev-parse --abbrev-ref HEAD)) };

    return 0 if not $branch;    # If git fails, we're not stable. See #546.

    return $branch =~ m{
        (\b|_)stable(\b|_)|   # Contains stable as a word (underscores ok)
        v\d+\.\d*[02468]$     # Ends with vx.y, where y is even.
    }x;
}
